# TDX Quote Verification Process

This document describes every step performed during Intel TDX (Trust Domain Extensions) attestation quote verification using the `tdx_pytools` library.

## Overview

The TDX quote verification process validates that a quote generated by a TDX-enabled system is authentic, comes from a legitimate Intel TDX platform, and has the expected security properties. The verification involves multiple cryptographic checks, certificate chain validation, and TCB (Trusted Computing Base) status evaluation.

## Table of Contents

1. [Quote Structure Verification](#1-quote-structure-verification)
2. [Certificate Loading and Validation](#2-certificate-loading-and-validation)
3. [Certificate Chain Verification](#3-certificate-chain-verification)
4. [Certificate Revocation List (CRL) Checks](#4-certificate-revocation-list-crl-checks)
5. [Cryptographic Signature Verification](#5-cryptographic-signature-verification)
6. [Attestation Key Binding](#6-attestation-key-binding)
7. [SGX Extension Extraction](#7-sgx-extension-extraction)
8. [QE Identity Verification](#8-qe-identity-verification)
9. [TCB Info Verification](#9-tcb-info-verification)
10. [TCB Status Evaluation](#10-tcb-status-evaluation)
11. [TD Debug Mode Check](#11-td-debug-mode-check)
12. [Terminal TCB Status Check](#12-terminal-tcb-status-check)

---

## 1. Quote Structure Verification

**Purpose**: Validate the basic structure and format of the TDX quote.

### Steps:

1. **Parse Quote Binary**
   - Deserialize the binary quote data into structured format
   - Extract: Header (48 bytes), Body (584 bytes for v4), Signature data

2. **Validate TEE Type**
   - Check that `header.tee_type == 0x00000081` (Intel TDX identifier)
   - Ensures this is a TDX quote, not SGX or other TEE type

3. **Check Signature Presence**
   - Verify `signature_len > 0`
   - Ensures the quote includes signature data

4. **Validate Quote Version**
   - Check `header.version` is one of: 3, 4, or 5
   - Log warning for unusual versions

5. **Validate Attestation Key Type**
   - Check `header.att_key_type`:
     - `2` = ECDSA-256-with-P-256 curve
     - `3` = ECDSA-384-with-P-384 curve
   - Log warning for other types

**Output**: Structured Quote object with validated basic properties

---

## 2. Certificate Loading and Validation

**Purpose**: Load and validate the required certificates and CRLs for verification.

### Required Certificates:

1. **Intel SGX Root CA Certificate** (`intel_sgx_root_ca.pem`)
   - Intel's root certificate authority
   - Self-signed root of trust

2. **Intel SGX Root CA CRL** (`intel_sgx_root_ca_crl.pem`)
   - Certificate Revocation List for intermediate certificates
   - Signed by Root CA

3. **Intel SGX PCK Platform CRL** (`intel_sgx_pck_platform_crl.pem`)
   - Certificate Revocation List for platform (PCK) certificates
   - Signed by PCK Platform CA

### Steps:

1. **Load from File or Fetch**
   - If `certificates_path` provided: Load from local files
   - Otherwise: Fetch from Intel PCS API

2. **Parse Certificates**
   - Load PEM-encoded X.509 certificates
   - Load PEM-encoded CRLs

3. **Validate Certificate Dates** (for each certificate)
   - Check `not_valid_before <= current_time <= not_valid_after`
   - Reject expired or not-yet-valid certificates

**Output**: Loaded and validated certificates (Root CA, Root CRL, Leaf CRL)

---

## 3. Certificate Chain Verification

**Purpose**: Verify the PCK (Platform Certificate Key) certificate chain from the quote.

### Certificate Chain Structure:

```
Quote -> PCK Certificate -> PCK Platform CA -> Intel Root CA
```

### Steps:

1. **Extract PCK Certificate Chain from Quote**
   - Parse `quote.signature_data.qe_cert_data.pck_cert_chain`
   - Should contain 3 certificates for certification data type 5
     - PCK, Intermediate CA, Root CA

2. **Verify Each Certificate Against Parent**
   - For each certificate in chain:
     - Verify signature using parent certificate's public key
     - Validates that each cert was issued by the next cert in chain

3. **Validate Root Certificate Match**
   - Compare fingerprint (SHA-256) of chain root with Intel Root CA
   - Ensures the chain terminates at the expected Intel root

4. **Certificate Chain Integrity**
   - Verify: `PCK_cert.verify(intermediate_ca.public_key())`
   - Verify: `intermediate_ca.verify(root_ca.public_key())`

**Output**: Validated PCK certificate chain rooted in Intel Root CA

---

## 4. Certificate Revocation List (CRL) Checks

**Purpose**: Ensure no certificates in the chain have been revoked.

### Steps:

1. **Verify Root CA CRL Signature**
   - Verify CRL is signed by Root CA's private key
   - Uses `root_ca.public_key()` to verify signature

2. **Verify PCK Platform CRL Signature**
   - Verify CRL is signed by PCK Platform CA's private key
   - Uses `pck_platform_ca.public_key()` to verify signature

3. **Check Platform Certificate Against Root CRL**
   - Search Root CA CRL for Platform certificate's serial number
   - If found: Certificate is revoked → FAIL
   - If not found: Certificate is valid → PASS

4. **Check PCK Certificate Against PCK Platform CRL**
   - Search PCK Platform CRL for PCK certificate's serial number
   - If found: Certificate is revoked → FAIL
   - If not found: Certificate is valid → PASS

**Output**: Confirmation that all certificates are not revoked

---

## 5. Cryptographic Signature Verification

**Purpose**: Verify cryptographic signatures to ensure quote authenticity and integrity.

### 5.1 QE Report Signature Verification

**Signed Data**: QE Report (384 bytes)

**Signature**: QE Report Signature (ECDSA signature)

**Signing Key**: PCK Certificate's public key

**Steps**:
1. Extract QE report bytes: `quote.signature_data.qe_cert_data.qe_report.to_bytes()`
2. Extract QE report signature: `quote.signature_data.qe_cert_data.qe_report_signature`
3. Convert signature to DER format
4. Get PCK certificate public key
5. Determine hash algorithm based on attestation key type:
   - Type 2 (P-256) → SHA-256
   - Type 3 (P-384) → SHA-384
6. Verify: `pck_public_key.verify(signature_der, qe_report_bytes, ec.ECDSA(hash_algo))`

**Proves**: The QE report was signed by the platform's PCK certificate

### 5.2 Quote Signature Verification

**Signed Data**: Header (48 bytes) + Body (584 bytes)

**Signature**: Quote Signature (ECDSA signature)

**Signing Key**: Attestation Public Key (from quote)

**Steps**:
1. Concatenate signed data: `header.to_bytes() + body.to_bytes()`
2. Extract attestation public key: `quote.signature_data.attestation_key`
3. Convert to cryptography key object
4. Extract quote signature: `quote.signature_data.signature`
5. Convert signature to DER format
6. Determine hash algorithm (based on attestation key type)
7. Verify: `attestation_key.verify(signature_der, signed_data, ec.ECDSA(hash_algo))`

**Proves**: The quote (header + body) was signed by the attestation key

---

## 6. Attestation Key Binding

**Purpose**: Verify that the attestation key is cryptographically bound to the QE report.

### Binding Algorithm:

The QE report's `report_data` field contains a hash that binds the attestation key:

```
For P-256: SHA-256(attestation_key || qe_auth_data) || 32 zero bytes
For P-384: SHA-384(attestation_key || qe_auth_data) || 32 zero bytes
```

### Steps:

1. **Extract Attestation Key**
   - Get uncompressed public key bytes: `attestation_key.to_uncompressed_bytes()`
   - Format: 0x04 || x-coordinate || y-coordinate

2. **Extract QE Authentication Data**
   - Get: `quote.signature_data.qe_cert_data.qe_authentication_data`

3. **Compute Expected Hash**
   - Concatenate: `attestation_key_bytes || qe_auth_data`
   - Hash with SHA-256 (P-256) or SHA-384 (P-384)
   - Result: Expected hash value

4. **Extract Actual Hash from QE Report**
   - Get first N bytes of `qe_report.report_data`
   - N = 32 for SHA-256, 48 for SHA-384

5. **Compare Hashes**
   - If `actual_hash == expected_hash`: Binding is valid
   - Otherwise: FAIL - attestation key is not properly bound

**Proves**: The attestation key that signed the quote is the one associated with this QE report

---

## 7. SGX Extension Extraction

**Purpose**: Extract Intel SGX-specific extensions from the PCK certificate.

### SGX Extensions (X.509 Certificate Extensions):

1. **PPID (Platform Provisioning ID)** - OID: 1.2.840.113741.1.13.1.4
   - 16-byte encrypted platform identifier
   - Uniquely identifies the platform

2. **TCB (Trusted Computing Base)** - OID: 1.2.840.113741.1.13.1.2
   - Contains TCB components (security version numbers)
   - Includes CPUSVN (16 bytes), PCESVN, and 16 SGX TCB component values

3. **PCE_ID (Platform Configuration Enclave ID)** - OID: 1.2.840.113741.1.13.1.3
   - 2-byte PCE identifier

4. **FMSPC (Family-Model-Stepping-Platform-CustomSKU)** - OID: 1.2.840.113741.1.13.1.1
   - 6-byte platform identifier used for TCB Info lookup

### Steps:

1. **Parse Certificate Extensions**
   - Iterate through PCK certificate's X.509 extensions
   - Match OIDs to known SGX extension types

2. **Extract TCB Components**
   - Parse TCB extension sequence (ASN.1 structure)
   - Extract 18 components:
     - **SGX_TCB_COMP01_SVN through SGX_TCB_COMP16_SVN** (integers)
     - **PCESVN** (integer)
     - **CPUSVN** (16-byte OctetString)

3. **Create TCB_parsed Dictionary**
   - Key format: `SGX_TCB_COMP{XX}_SVN`, `PCESVN`, `CPUSVN`
   - Values: Integer or bytes as appropriate

4. **Validate Required Extensions**
   - Ensure all required OIDs are present
   - If missing: FAIL with error message

**Output**: Dictionary containing SGX extensions, especially `TCB_parsed` with all 18 TCB components

---

## 8. QE Identity Verification

**Purpose**: Verify the Quoting Enclave (QE) identity and determine its TCB status.

### Data Sources:

1. **QE Report** (from quote): Contains QE measurements
2. **QE Identity** (from Intel PCS): Trusted reference values

### Steps:

#### 8.1 Fetch QE Identity

1. **Retrieve QE Identity Document**
   - Source: Intel Provisioning Certification Service (PCS) API
   - Endpoint: `/sgx/certification/v4/qe/identity`
   - Format: JSON document with signature

2. **Load QE Identity Signing Certificate**
   - Certificate chain for QE Identity signature verification
   - Issued by Intel SGX & TDX TCB Signing CA

#### 8.2 Verify QE Identity Signature

1. **Validate Signing Certificate**
   - Check certificate dates (not expired)
   - Check certificate against Root CA CRL (not revoked)
   - Verify certificate is signed by Root CA

2. **Extract Signature from JSON**
   - Parse `response['signature']` (hex-encoded ECDSA signature)
   - Parse `response['enclaveIdentity']` (the signed data)

3. **Verify JSON Signature**
   - Signed data: The `enclaveIdentity` JSON object (as-is from response)
   - Signature: ECDSA-256 signature
   - Verify using signing certificate's public key

**Proves**: The QE Identity document is authentic and from Intel

#### 8.3 Verify QE Report Against Identity

**Fields to Verify**:

1. **MRSIGNER** (Measurement of signer - 32 bytes)
   - From QE Report: `qe_report.mr_signer`
   - From QE Identity: `enclaveIdentity['mrsigner']`
   - Must match exactly (case-insensitive hex comparison)

2. **ISVPRODID** (Independent Software Vendor Product ID - 2 bytes)
   - From QE Report: `qe_report.isv_prod_id`
   - From QE Identity: `enclaveIdentity['isvprodid']`
   - Must match exactly

3. **MISCSELECT** (Miscellaneous Select - 4 bytes)
   - From QE Report: `qe_report.misc_select`
   - Mask from QE Identity: `enclaveIdentity['miscselectMask']`
   - Expected from QE Identity: `enclaveIdentity['miscselect']`
   - Verify: `(qe_report.misc_select & mask) == expected`

4. **ATTRIBUTES** (Attributes - 16 bytes)
   - From QE Report: `qe_report.attributes`
   - Mask from QE Identity: `enclaveIdentity['attributesMask']`
   - Expected from QE Identity: `enclaveIdentity['attributes']`
   - Verify: `(qe_report.attributes & mask) == expected`

**Proves**: The QE is the authentic Intel Quoting Enclave with expected identity

#### 8.4 Determine QE TCB Status

1. **Extract ISVSVN**
   - Get `qe_report.isv_svn` (Independent Software Vendor Security Version Number)

2. **Find Matching TCB Level**
   - Iterate through `enclaveIdentity['tcbLevels']` (sorted, highest first)
   - Find first level where `qe_report.isv_svn >= tcb_level['tcb']['isvsvn']`

3. **Extract TCB Status**
   - Status: `tcb_level['tcbStatus']` (e.g., "UpToDate", "OutOfDate")
   - Date: `tcb_level['tcbDate']` (when this TCB level was issued)
   - Advisory IDs: `tcb_level['advisoryIDs']` (list of security advisories)

**Output**: QE TCB Status, TCB Date, Advisory IDs

---

## 9. TCB Info Verification

**Purpose**: Verify the platform's Trusted Computing Base (TCB) information and status.

### Data Sources:

1. **Platform TCB Components** (from PCK certificate): Current platform TCB levels
2. **TEE TCB SVN** (from quote body): TDX-specific TCB components
3. **TCB Info** (from Intel PCS): Reference TCB levels and statuses

### Steps:

#### 9.1 Fetch TCB Info

1. **Extract FMSPC**
   - From PCK certificate SGX extensions: `sgx_exts['FMSPC']`
   - 6-byte identifier: Family-Model-Stepping-Platform-CustomSKU

2. **Validate FMSPC Format**
   - Ensure it's 12 hex characters (6 bytes)

3. **Retrieve TCB Info Document**
   - Source: Intel PCS API
   - Endpoint: `/tdx/certification/v4/tcb?fmspc={FMSPC}`
   - Type parameter: `type=TDX` (for TDX platforms)
   - Format: JSON document with signature

4. **Load TCB Info Signing Certificate**
   - Certificate chain for TCB Info signature verification
   - Issued by Intel SGX & TDX TCB Signing CA

#### 9.2 Verify TCB Info Signature

1. **Validate Signing Certificate**
   - Check certificate dates (not expired)
   - Check certificate against Root CA CRL (not revoked)
   - Verify certificate is signed by Root CA

2. **Extract Signature from JSON**
   - Parse `response['signature']` (hex-encoded ECDSA signature)
   - Parse `response['tcbInfo']` (the signed data)

3. **Verify JSON Signature**
   - Signed data: The `tcbInfo` JSON object (as-is from response)
   - Signature: ECDSA-256 signature
   - Verify using signing certificate's public key

**Proves**: The TCB Info document is authentic and from Intel

#### 9.3 Validate TCB Info Structure

1. **Check TCB Info ID**
   - Verify: `tcbInfo['id'] == "TDX"`
   - Ensures this is TDX TCB info, not SGX

2. **Validate TCB Info Version**
   - Check `tcbInfo['version']` is supported

3. **Validate Required Fields**
   - `tcbInfo['tcbLevels']`: Array of TCB levels (must not be empty)
   - `tcbInfo['issueDate']`: When TCB info was issued
   - `tcbInfo['nextUpdate']`: When next update is expected
   - `tcbInfo['tdxModuleIdentities']`: TDX module identity information

**Output**: Validated and parsed TCB Info structure

---

## 10. TCB Status Evaluation

**Purpose**: Determine the platform's TCB status by matching platform TCB components against reference TCB levels.

### Input Data:

1. **Platform SGX TCB Components** (from PCK certificate):
   - SGX_TCB_COMP01_SVN through SGX_TCB_COMP16_SVN (16 integers)
   - PCESVN (Platform Configuration Enclave SVN)
   - CPUSVN (CPU Security Version Number - 16 bytes)

2. **Platform TEE TCB SVN** (from quote body):
   - 16-byte array from `quote.body.tee_tcb_svn`
   - Contains TDX-specific TCB components

3. **TCB Levels** (from TCB Info):
   - Array of reference TCB levels with status
   - Sorted from highest to lowest security

### Algorithm: Intel TCB Level Matching

This implements the algorithm from Intel's PCS API specification.

#### Step 1: Validate Input Data

1. **Check Platform SGX TCB Components**
   - Verify all 16 SGX components are present
   - Verify PCESVN is present

2. **Check TEE TCB SVN**
   - Verify it's 16 bytes
   - Convert to integer array for comparison

3. **Check TCB Levels**
   - Verify at least one TCB level exists
   - If none: Return status = "NotSupported"

#### Step 2: Iterate Through TCB Levels (Highest to Lowest)

For each TCB level in `tcbInfo['tcbLevels']`:

##### Step 2.a: Compare SGX TCB Components

**For each of 16 SGX components**:
```
Compare: platform_sgx_tcb[i] >= tcb_level['sgxtcbcomponents'][i]['svn']
```

**Result**: If ALL components match → Continue to step 2.b
           If ANY component fails → Move to next TCB level

##### Step 2.b: Compare PCESVN

```
Compare: platform_pcesvn >= tcb_level['pcesvn']
```

**Result**: If match → Continue to step 2.c
           If no match → Move to next TCB level

##### Step 2.c: Compare TDX TCB Components

**Determine Comparison Range**:
```
If TEE_TCB_SVN[1] == 0:
    Compare indices 0-15
Else:
    Compare indices 2-15
```

**For each TDX component in range**:
```
Compare: platform_tee_tcb_svn[i] >= tcb_level['tdxtcbcomponents'][i]['svn']
```

**Result**: If ALL components match → Match found, Go to step 3
           If ANY component fails → Move to next TCB level

#### Step 3: Extract Platform TCB Status

**If match found**:

Assign TCB Status, Date and Advisory IDs

**If no match found after checking all levels**:
```
TCB Status: "NotSupported"
TCB Date: None
Advisory IDs: []
```

#### Step 4: TDX Module Evaluation (Conditional)

**Condition**: Only perform if `TEE_TCB_SVN[1] >= 1`

**Purpose**: Verify the TDX Module version

##### Step 4.1: Determine TDX Module Version

```
TDX Version = TEE_TCB_SVN[1]
TDX Module ID = f"TDX_{TDX_Version:02d}"  (e.g., "TDX_01")
```

##### Step 4.2: Find Matching TDX Module Identity

Search `tcbInfo['tdxModuleIdentities']` for entry with matching `id`:

**If no match**: Set status = "NotSupported" and skip to step 5

##### Step 4.3: Compare Module ISVSVN

For each level in `tdxModuleIdentity['tcbLevels']`:

```
Compare: TEE_TCB_SVN[0] >= module_tcb_level['tcb']['isvsvn']
```

**If match**: Extract module TCB status

##### Step 4.4: Combine Platform and Module Status

Use priority-based status combination.


##### Step 4.5: Combine Advisory IDs


##### Step 4.6: Select Most Recent Date


#### Step 5: Handle Missing Module TCB Level

**If no module TCB level matched**:
```
Final Status = "NotSupported"
```

**Output**: Final TCB Status, TCB Date, Advisory IDs

---

## 11. TD Debug Mode Check

**Purpose**: Verify that the Trust Domain (TD) is not running in debug mode, which would make it untrusted.

We do this as the final verification step, after all other checks have completed. This allows debugging of other issues if the TD is in debug mode.

**TUD (TD Under Debug) Flags - Bits 7:0**:
- Located in byte 0 of the `td_attributes` field
- If ANY bit in this group (bits 7:0) is set to 1, the TD is considered **untrusted**

**DEBUG Flag - Bit 0**:
- Defines whether the TD runs in TD debug mode
- `0` = Not in debug mode (trusted)
- `1` = In debug mode (untrusted)

**Security Impact**: In TD debug mode, the CPU state and private memory are accessible by the host VMM (Virtual Machine Manager), which violates the security guarantees of a trusted execution environment.

### Steps:

1. **Extract TD Attributes**
   - Get `quote.body.td_attributes` (8 bytes)
   - Extract byte 0 (TUD flags)

2. **Check TUD Bits**
   ```
   tud_byte = td_attributes[0]
   if tud_byte != 0:
       # TD is untrusted
   ```

3. **Determine Specific Issue**
   - If bit 0 is set: TD is in DEBUG mode
   - If any other TUD bits are set: Other debug-related flags are active

4. **Verification Result**
   - **PASS**: All TUD bits are 0 → TD is not in debug mode (trusted)
   - **FAIL**: Any TUD bits set → TD is untrusted, reject the quote

**Output**: Verification passes only if `td_attributes[0] == 0x00`

---

## 12. Terminal TCB Status Check

**Purpose**: Check if the combined TCB status represents a terminal failure condition that should cause the verification process to fail.

### Background

Some TCB statuses represent terminal conditions that indicate the platform cannot be trusted for attestation and should cause the verification process to fail immediately. The `is_terminal()` function checks for these critical failure states.

### Terminal TCB Statuses

**Terminal Statuses** (Verification should fail):
- `Revoked` - Platform TCB has been revoked due to security vulnerabilities
- `NotSupported` - Platform TCB level is not supported/recognized by Intel

**Non-Terminal Statuses** (Verification continues):
- `UpToDate` - Platform is fully up to date
- `SWHardeningNeeded` - Software hardening recommended
- `ConfigurationNeeded` - Configuration changes needed
- `ConfigurationAndSWHardeningNeeded` - Both needed
- `OutOfDate` - Platform TCB is out of date
- `OutOfDateConfigurationNeeded` - Out of date with config needed

### Steps:

1. **Get Combined TCB Status**
   - Extract the final combined TCB status from all TCB evaluations
   - This represents the worst-case status from platform, QE, and TDX module TCBs

2. **Check Terminal Condition**
   ```python
   # Check if the TCB status is terminal (should cause failure)
   if combined_tcb.status.is_terminal():
       raise ValueError(f"Verification failed: Terminal TCB status '{combined_tcb.status.value}'")
   ```

3. **Verification Decision**
   - **CONTINUE**: If status is non-terminal → Verification continues
   - **FAIL**: If status is terminal → Raise exception and stop verification

**Output**: Verification either continues (non-terminal) or fails with exception (terminal status) 

---

## Summary: Complete Verification Flow

```
1. Parse Quote Binary
   ↓
2. Validate Quote Structure
   ↓
3. Load Certificates & CRLs
   ↓
4. Verify Certificate Chain
   ↓
5. Check Certificate Revocation (CRLs)
   ↓
6. Verify QE Report Signature (using PCK cert)
   ↓
7. Verify Quote Signature (using attestation key)
   ↓
8. Verify Attestation Key Binding (to QE report)
   ↓
9. Extract SGX Extensions (TCB components, FMSPC, etc.)
   ↓
10. Fetch & Verify QE Identity (from Intel PCS)
    ↓
11. Determine QE TCB Status
    ↓
12. Fetch & Verify TCB Info (from Intel PCS)
    ↓
13. Run TCB Matching Algorithm
    ↓
14. Evaluate Platform TCB Status
    ↓
15. Evaluate TDX Module Status (if applicable)
    ↓
16. Combine Statuses → FINAL RESULT
    ↓
17. Verify TD Not in Debug Mode (Final Check)
    ↓
18. Terminal TCB Status Check
    ↓
19. Begin Policy Checks
```

## Exit Status

### Success (Exit Code 0)

All verification steps passed. The quote is:
- Cryptographically valid
- From a legitimate Intel TDX platform
- Not revoked
- TCB status determined (may not be "UpToDate" but is determined)

The quote should now be evaluated according to a policy.

### Failure (Exit Code 1)

Any verification step failed:
- Invalid signature
- Expired/revoked certificate
- TCB component mismatch
- Missing required data
- Structural errors
- Terminal TCB status

## Post-Verification Checks

Immediately after verification, quote.body.report_data needs to be checked against the nonce and possibly a hashed key, to ensure freshness.

The following possibly needs to be checked as a matter of policy after verification is successful:

- quote.header.qe_vendor_id
- quote.header.user_data
- quote.body.mr_seam
- quote.body.td_attributes (except debug which is pass/fail)
- quote.body.xfam
- quote.body.mr_td
- quote.body.mr_config_id
- quote.body.mr_owner/mr_owner_config
- quote.body.rtmr[0-3]

## Currently Not Checked
- qe_report.cpu_svn (match to pck?)
- qe_report.mr_enclave

---

**Document Version**: 1.0  
**Last Updated**: October 21, 2025  
**Author**: Isaac Matthews
