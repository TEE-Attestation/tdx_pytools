# Copyright 2025 Hewlett Packard Enterprise Development LP.
# SPDX-License-Identifier: MIT
#
# TDX quote verification - Complete attestation verification for Intel TDX quotes.

import argparse
import json
import os
from typing import Any, Dict, List, Optional, Tuple

from cryptography import x509
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec, utils

from . import tdx_logging
from .certs import (
    check_certificate_against_crl,
    validate_certificate_dates,
    verify_certificate,
    verify_crl,
)
from .ecdsa import get_hash_algorithm
from .fetch import (
    CertFormat,
    fetch_crls,
    fetch_qe_identity,
    fetch_root_ca_crl,
    fetch_tcb_info,
    request_pck_crl,
    request_root_ca_crl,
    validate_fmspc,
    write_crl,
)
from .policy import AttestationPolicy, PolicyValidationError, validate_quote_with_policy
from .quote import Quote
from .tcb import Tcb, TcbStatus, combine_tcb_status, tcb_verify

# Get logger for this module
logger = tdx_logging.get_logger(__name__)

default_path = "./certs"


def verify_quote_signature(quote: Quote) -> bool:
    """
    Verify the quote signature using the attestation public key.

    The quote signature covers the header and body of the quote and ensures
    the integrity and authenticity of the quote data.

    Args:
        quote: Quote object containing header, body, and signature data

    Returns:
        bool: True if signature is valid

    Raises:
        ValueError: If signature verification fails
    """
    try:
        # The signed data is: header (48 bytes) + body (584 bytes for v4)
        signed_data = quote.header.to_bytes() + quote.body.to_bytes()

        # Get the attestation public key from the quote
        attestation_key = quote.signature_data.attestation_key.to_cryptography_key()

        # Get the signature in DER format for cryptography library
        signature_der = quote.signature_data.signature.to_der()

        # Get the appropriate hash algorithm
        hash_algo = get_hash_algorithm(quote.header.att_key_type)

        # Verify the signature
        attestation_key.verify(signature_der, signed_data, ec.ECDSA(hash_algo))

        tdx_logging.log_verification_step(
            "Quote Signature Verification",
            "PASS",
            "Quote signature is signed by attestation key",
        )
        return True

    except InvalidSignature:
        raise ValueError("Quote signature verification failed: Invalid signature")
    except Exception as e:
        raise ValueError(f"Quote signature verification failed: {str(e)}")


def verify_qe_report_signature(quote: Quote) -> bool:
    """
    Verify the QE (Quoting Enclave) report signature using the PCK certificate.

    The QE report signature proves that the QE report was generated by a
    genuine Intel Quoting Enclave and signed with the platform's PCK key.

    Args:
        quote: Quote object containing QE report and signature data

    Returns:
        bool: True if signature is valid

    Raises:
        ValueError: If signature verification fails
    """
    try:
        # Get the QE report (384 bytes)
        qe_report = quote.signature_data.qe_cert_data.qe_report
        qe_report_bytes = qe_report.to_bytes()

        # Get the QE report signature
        qe_signature = quote.signature_data.qe_cert_data.qe_report_signature
        qe_signature_der = qe_signature.to_der()

        # Get the PCK certificate public key
        pck_cert = quote.signature_data.qe_cert_data.pck_cert_chain.pck_cert
        pck_public_key = pck_cert.public_key()

        # Get the appropriate hash algorithm
        hash_algo = get_hash_algorithm(quote.header.att_key_type)

        # Verify the signature
        pck_public_key.verify(qe_signature_der, qe_report_bytes, ec.ECDSA(hash_algo))

        tdx_logging.log_verification_step(
            "QE Report Signature Verification", "PASS", "QE report signature is valid"
        )
        return True

    except InvalidSignature:
        raise ValueError("QE report signature verification failed: Invalid signature")
    except Exception as e:
        raise ValueError(f"QE report signature verification failed: {str(e)}")


def verify_attestation_key_binding(quote: Quote) -> bool:
    """
    Verify that the attestation key is bound to the QE report.

    The QE report's report_data field should contain a hash that binds the attestation
    public key to the quote:
        SHA-256(ECDSA attestation_key || qe_auth_data) || 32-0x00's - from spec
        SHA-384(ECDSA attestation_key || qe_auth_data) || 32-0x00's - assumed for P-384

    This binding ensures that the attestation key used to sign the quote is
    cryptographically linked to the QE report.

    Args:
        quote: Quote object containing attestation key and QE report data

    Returns:
        bool: True if binding is valid

    Raises:
        ValueError: If binding verification fails
    """
    try:
        # Get the attestation public key bytes
        attestation_key_bytes = (
            quote.signature_data.attestation_key.to_uncompressed_bytes()
        )

        # Get the QE authentication data
        qe_auth_data = quote.signature_data.qe_cert_data.qe_authentication_data

        # Get the appropriate hash algorithm and compute the digest
        hash_algo = get_hash_algorithm(quote.header.att_key_type)

        # Hash the attestation key concatenated with QE auth data
        # This is the standard binding method for Intel TDX/SGX quotes

        digest = hashes.Hash(hash_algo)
        digest.update(attestation_key_bytes)
        digest.update(qe_auth_data)
        expected_hash = digest.finalize()

        # Get the QE report data
        qe_report_data = quote.signature_data.qe_cert_data.qe_report.report_data

        # The hash should be in the first part of the report_data
        hash_len = len(expected_hash)
        actual_hash = qe_report_data[:hash_len]

        if actual_hash != expected_hash:
            raise ValueError(
                f"Attestation key binding verification failed: "
                f"Expected hash {expected_hash.hex()}, got {actual_hash.hex()}"
            )

        tdx_logging.log_verification_step(
            "Attestation Key Binding",
            "PASS",
            "Attestation key is properly bound to QE report",
        )
        return True

    except Exception as e:
        if isinstance(e, ValueError):
            raise
        raise ValueError(f"Attestation key binding verification failed: {str(e)}")


def verify_raw_response(
    raw_response: str,
    signing_cert: x509.Certificate,
    root_cert: x509.Certificate,
    root_crl: x509.CertificateRevocationList,
) -> Dict[str, Any]:
    """
    Verify either the QE Identity or TCB Info raw response.

    The signature is calculated over the enclaveIdentity/tcbInfo body (without whitespaces)
    using the signing key corresponding to SGX & TDX TCB Signing Certificate.

    Args:
        raw_response: Raw JSON response string from Intel
        signing_cert: x509.Certificate (SGX & TDX TCB Signing Certificate)

    Returns:
        dict: Parsed response JSON object if signature is valid

    Raises:
        ValueError: If signature verification fails
    """
    # Cert checks
    if not validate_certificate_dates(signing_cert):
        raise ValueError("Signing certificate is expired or not yet valid")
    if not check_certificate_against_crl(signing_cert, root_crl):
        raise ValueError("Signing certificate is revoked according to Root CA CRL")
    # Check signing cert is signed by root cert
    if not verify_certificate(signing_cert, root_cert.public_key()):
        raise ValueError(
            "Signing certificate verification failed against Root CA certificate"
        )

    try:
        # Parse the raw JSON to get the signature
        response = json.loads(raw_response)

        if "enclaveIdentity" not in response:
            if "tcbInfo" not in response:
                raise ValueError(
                    "Response JSON missing 'enclaveIdentity' and 'tcbInfo' fields"
                )
            else:
                search_str = '"tcbInfo":'
        else:
            search_str = '"enclaveIdentity":'
        if "signature" not in response:
            raise ValueError("Response JSON missing 'signature' field")

        signature_hex = response["signature"]

        # json dumps pretty prints so manually editing the response text here
        # Probably a better way to do this but this works for now
        # Extract the enclaveIdentity/tcbInfo portion from the raw JSON string
        # Find where search_str starts

        start_pos = raw_response.find(search_str)
        if start_pos == -1:
            raise ValueError(f"Could not find {search_str} in raw JSON")

        start_pos += len(search_str)

        # Count braces to find the matching closing brace
        brace_count = 0
        found_start = False
        response_json = None

        for i in range(start_pos, len(raw_response)):
            if raw_response[i] == "{":
                if not found_start:
                    found_start = True
                brace_count += 1
            elif raw_response[i] == "}":
                brace_count -= 1
                if brace_count == 0:
                    # Found the matching closing brace
                    response_json = raw_response[start_pos : i + 1]
                    break

        if response_json is None:
            raise ValueError(f"Could not extract {search_str} JSON object")

        # The signed data is the enclaveIdentity/tcbInfo JSON object as-is from the response
        signed_data = response_json.encode()
        logger.debug(f"Signed data length: {len(signed_data)} bytes")

        # Convert hex signature to bytes
        signature_bytes = bytes.fromhex(signature_hex)

        r = int.from_bytes(signature_bytes[:32], byteorder="big")
        s = int.from_bytes(signature_bytes[32:], byteorder="big")
        der_signature = utils.encode_dss_signature(r, s)

        public_key = signing_cert.public_key()
        # Verify the signature
        public_key.verify(der_signature, signed_data, ec.ECDSA(hashes.SHA256()))

        logger.debug("Response signature verification successful")
        tdx_logging.log_verification_step(
            "Response Signature Verification",
            "PASS",
            "Response signature is valid",
        )
        return response

    except InvalidSignature:
        raise ValueError("Response signature verification failed: Invalid signature")
    except Exception as e:
        raise ValueError(f"Response signature verification failed: {str(e)}")


def verify_enclave_identity(
    qe_report: Any,
    qe_identity_raw: str,
    qe_identity_certs: List[x509.Certificate],
    root_cert: x509.Certificate,
    root_crl: x509.CertificateRevocationList,
) -> Tcb:
    """
    Verify the enclave identity from the QE Identity document.

    Args:
        qe_report: QE report object from the quote
        qe_identity_raw: Raw JSON response string
        qe_identity_certs: QE Identity signing certificate (list of x509 certificates)
        root_cert: Root CA certificate
        root_crl: Root CA CRL

    Returns:
        TCB object containing status, date, and advisory IDs

    Raises:
        ValueError: If enclave identity verification fails
    """
    try:
        # Verify the QE Identity signature and certs
        qe_identity = verify_raw_response(
            qe_identity_raw, qe_identity_certs[0], root_cert, root_crl
        )["enclaveIdentity"]

        # https://api.portal.trustedservices.intel.com/content/documentation.html#pcs-enclave-identity-v4
        # Verify if MRSIGNER field retrieved from SGX Enclave Report is equal to the value of mrsigner field in Enclave Identity.
        # Verify if ISVPRODID field retrieved from SGX Enclave Report is equal to the value of isvprodid field in Enclave Identity.
        # Apply miscselectMask (binary mask) from Enclave Identity to MISCSELECT field retrieved from SGX Enclave Report. Verify if the outcome (miscselectMask & MISCSELECT) is equal to the value of miscselect field in Enclave Identity.
        # Apply attributesMask (binary mask) from Enclave Identity to ATTRIBUTES field retrieved from SGX Enclave Report. Verify if the outcome (attributesMask & ATTRIBUTES) is equal to the value of attributes field in Enclave Identity.
        if not qe_identity.get("mrsigner").upper() == qe_report.mr_signer.hex().upper():
            raise ValueError(
                f"MRSIGNER mismatch: Enclave Report MRSIGNER {qe_report.mr_signer.hex().upper()} != Enclave Identity mrsigner {qe_identity.get('mrsigner').upper()}"
            )

        if not qe_identity.get("isvprodid") == qe_report.isv_prod_id:
            raise ValueError(
                f"ISVPRODID mismatch: Enclave Report ISVPRODID {qe_report.isv_prod_id} != Enclave Identity isvprodid {qe_identity.get('isvprodid')}"
            )

        # Convert hex strings from JSON to bytes for comparison
        miscselect_mask = bytes.fromhex(qe_identity.get("miscselectMask"))
        miscselect_expected = bytes.fromhex(qe_identity.get("miscselect"))
        attributes_mask = bytes.fromhex(qe_identity.get("attributesMask"))
        attributes_expected = bytes.fromhex(qe_identity.get("attributes"))

        # Perform bitwise AND on bytes
        miscselect_masked = bytes(
            a & b for a, b in zip(qe_report.misc_select, miscselect_mask)
        )
        attributes_masked = bytes(
            a & b for a, b in zip(qe_report.attributes, attributes_mask)
        )

        if miscselect_masked != miscselect_expected:
            raise ValueError(
                f"MISCSELECT mismatch: (Enclave Report MISCSELECT {qe_report.misc_select.hex()} & miscselectMask {miscselect_mask.hex()}) = {miscselect_masked.hex()} != Enclave Identity miscselect {miscselect_expected.hex()}"
            )

        if attributes_masked != attributes_expected:
            raise ValueError(
                f"ATTRIBUTES mismatch: (Enclave Report ATTRIBUTES {qe_report.attributes.hex()} & attributesMask {attributes_mask.hex()}) = {attributes_masked.hex()} != Enclave Identity attributes {attributes_expected.hex()}"
            )

        logger.info(
            "MRSIGNER, ISVPRODID, MISCSELECT, and ATTRIBUTES from QE report valid according to Enclave Identity"
        )

        # Find TCB status of QE
        logger.debug(f"QE ISVSVN: {qe_report.isv_svn}")
        tcb_status = "NotSupported"
        tcb_date = None
        advisory_ids = []
        for s in qe_identity.get("tcbLevels"):
            if qe_report.isv_svn >= s["tcb"]["isvsvn"]:
                logger.debug(
                    f"Matched ISVSVN Level: {s['tcb']['isvsvn']}, Status: {s['tcbStatus']}, Advisory IDs: {s.get('advisoryIDs', [])}"
                )
                tcb_status = TcbStatus.from_string(s["tcbStatus"])
                tcb_date = s["tcbDate"]
                advisory_ids = s.get("advisoryIDs", [])
                break
        return Tcb(status=tcb_status, date=tcb_date, advisory_ids=advisory_ids)
    except Exception as e:
        # Wrap any other unexpected exceptions
        raise ValueError(f"Enclave identity verification failed: {str(e)}")


def verify_tcb_info(
    quote: Quote,
    sgx_tcb_comps: List[Any],
    tcb_info_raw: str,
    tcb_info_certs: List[x509.Certificate],
    root_cert: x509.Certificate,
    root_crl: x509.CertificateRevocationList,
) -> Dict[str, Tcb]:
    """
    Verify the TCB Info document and extract TCB status information.

    Args:
        quote: Quote object
        sgx_tcb_comps: SGX TCB component values from certificate extensions
        tcb_info_raw: Raw TCB Info JSON response string
        tcb_info_certs: TCB Info signing certificate (list of x509 certificates)
        root_cert: Root CA certificate
        root_crl: Root CA CRL

    Returns:

    Raises:
        ValueError: If enclave identity verification fails
    """
    try:
        # Verify the TCB Info signature and certs
        tcb_info = verify_raw_response(
            tcb_info_raw, tcb_info_certs[0], root_cert, root_crl
        )["tcbInfo"]

        # Verify the TCB Info fields
        if tcb_info.get("id") != "TDX":
            raise ValueError(f"Invalid TCB Info ID: {tcb_info.get('id')}")

        tcb_dict = tcb_verify(tcb_info, sgx_tcb_comps, quote.body.tee_tcb_svn)

        logger.info("TCB Info verification successful")
        return tcb_dict
    except Exception as e:
        # Wrap any other unexpected exceptions
        raise ValueError(f"TCB Info verification failed: {str(e)}")


def verify_td_attributes(quote: Quote) -> None:
    """
    Verify the TD attributes to ensure the TD is not running in debug mode.

    Args:
        quote: Quote object with td_attributes field

    Raises:
        ValueError: If TD is running in debug mode (untrusted)
    """
    # td_attributes is 8 bytes
    # Byte 0 contains TUD bits [7:0]
    td_attributes = quote.body.td_attributes
    tud_byte = td_attributes[0]

    # Check if any of the TUD bits (first byte, bits 7:0) are set
    if tud_byte != 0:
        # At least one TUD bit is set, TD is untrusted
        debug_flag = tud_byte & 0x01

        if debug_flag:
            raise ValueError(
                f"TD is running in DEBUG mode (td_attributes[0] = 0x{tud_byte:02x}). "
                "In debug mode, CPU state and private memory are accessible by the host VMM. "
                "The TD is untrusted."
            )
        else:
            raise ValueError(
                f"TD has TUD (TD Under Debug) flags set (td_attributes[0] = 0x{tud_byte:02x}). "
                "The TD is untrusted."
            )

    tdx_logging.log_verification_step(
        "TD Debug Mode Check",
        "PASS",
        "TD is not running in debug mode (td_attributes TUD bits are all 0)",
    )

    logger.debug(f"TD Attributes: {td_attributes.hex()}")


def verify_quote_structure(quote: Quote) -> bool:
    """
    Verify the basic structure and integrity of a TDX quote.

    Args:
        quote: Quote object

    Returns:
        True if quote structure is valid

    Raises:
        ValueError: If any structural validation fails
    """
    # Basic structural validation
    if quote.header.tee_type != 0x00000081:
        raise ValueError(
            f"Invalid TEE type: 0x{quote.header.tee_type:08x}, expected 0x00000081 for TDX"
        )

    tdx_logging.log_verification_step(
        "TEE Type Validation", "PASS", "Valid for Intel TDX"
    )

    if quote.signature_len == 0:
        raise ValueError("No signature present in quote")

    tdx_logging.log_verification_step(
        "Signature Presence", "PASS", "Signature is present in quote"
    )

    # Check quote version
    if quote.header.version not in [3, 4, 5]:  # Common TDX quote versions
        tdx_logging.log_verification_step(
            "Quote Version", "WARNING", f"Unusual quote version {quote.header.version}"
        )
    else:
        tdx_logging.log_verification_step(
            "Quote Version", "PASS", f"Quote version {quote.header.version} is valid"
        )

    # Check attestation key type
    if quote.header.att_key_type.value == 2:
        tdx_logging.log_verification_step(
            "Attestation Key Type", "PASS", "ECDSA-256-with-P-256 curve"
        )
    elif quote.header.att_key_type.value == 3:
        tdx_logging.log_verification_step(
            "Attestation Key Type", "PASS", "ECDSA-384-with-P-384 curve"
        )
    else:
        tdx_logging.log_verification_step(
            "Attestation Key Type",
            "WARNING",
            f"Unusual attestation key type {quote.header.att_key_type}",
        )

    tdx_logging.log_verification_step(
        "Quote Structure Verification", "PASS", "All structural checks passed"
    )

    return True


def load_certificates_and_collateral(
    quote: Quote, certificates_path: str = default_path, update: str = "standard"
) -> Dict[str, Any]:
    """
    Load all required certificates and collateral for TDX quote verification.

    Args:
        quote: Quote object (needed for FMSPC extraction)
        certificates_path: Path to certificates directory (if not provided, certificates are fetched)
        update: Update policy for fetching collateral ("early"|"standard")

    Returns:
        Dictionary containing all loaded certificates and collateral:
            - 'root_cert': Intel SGX Root CA certificate
            - 'root_crl': Intel SGX Root CA CRL
            - 'leaf_crl': Intel SGX PCK Platform CRL
            - 'qe_identity_raw': Raw QE Identity JSON response
            - 'qe_identity_certs': QE Identity signing certificates
            - 'tcb_info_raw': Raw TCB Info JSON response
            - 'tcb_info_certs': TCB Info signing certificates
            - 'sgx_extensions': Parsed SGX extensions from PCK certificate
            - 'fmspc': Validated FMSPC value
            - 'update': Update policy used

    Raises:
        ValueError: For verification failures
        FileNotFoundError: If certificates cannot be loaded
    """
    root_cert, root_crl, leaf_crl = None, None, None

    # Load certificates and CRLs
    if certificates_path is not None:
        logger.info(f"Certificate path provided: {certificates_path}")
        # Create certificates directory if it doesn't exist
        if not os.path.exists(certificates_path):
            os.makedirs(certificates_path)
            logger.info(f"Created certificates directory: {certificates_path}")
        elif not os.path.isdir(certificates_path):
            raise FileNotFoundError(
                f"Certificates path '{certificates_path}' exists but is not a directory"
            )

        # Check for and load/download Root CA certificate
        root_cert_path = os.path.join(certificates_path, "intel_sgx_root_ca.pem")
        if os.path.exists(root_cert_path):
            with open(root_cert_path, "rb") as f:
                root_cert = x509.load_pem_x509_certificate(f.read())
            logger.info(f"Loaded existing Root CA certificate from {root_cert_path}")
        else:
            logger.info(f"Root CA certificate not found, downloading...")
            root_cert, root_crl = fetch_root_ca_crl(CertFormat.PEM, certificates_path)
            logger.info(f"Downloaded and saved Root CA certificate to {root_cert_path}")

        # Check for and load/download Root CA CRL (if not already downloaded above)
        root_crl_path = os.path.join(certificates_path, "intel_sgx_root_ca_crl.pem")
        if root_crl is None:  # Only load if not already downloaded
            if os.path.exists(root_crl_path):
                with open(root_crl_path, "rb") as f:
                    root_crl = x509.load_pem_x509_crl(f.read())
                logger.info(f"Loaded existing Root CA CRL from {root_crl_path}")
            else:
                logger.info(f"Root CA CRL not found, downloading...")
                if root_cert is None:
                    # Need to load root cert first to get CRL
                    with open(root_cert_path, "rb") as f:
                        root_cert = x509.load_pem_x509_certificate(f.read())
                root_crl = request_root_ca_crl(root_cert)
                write_crl(
                    certificates_path, "intel_sgx_root_ca_crl", root_crl, CertFormat.PEM
                )
                logger.info(f"Downloaded and saved Root CA CRL to {root_crl_path}")

        # Check for and load/download PCK Platform CRL (leaf CRL)
        leaf_crl_path = os.path.join(
            certificates_path, "intel_sgx_pck_platform_crl.pem"
        )
        if os.path.exists(leaf_crl_path):
            with open(leaf_crl_path, "rb") as f:
                leaf_crl = x509.load_pem_x509_crl(f.read())
            logger.info(f"Loaded existing PCK Platform CRL from {leaf_crl_path}")
        else:
            logger.info(f"PCK Platform CRL not found, downloading...")
            leaf_crl = request_pck_crl("platform")
            write_crl(
                certificates_path,
                "intel_sgx_pck_platform_crl",
                leaf_crl,
                CertFormat.PEM,
            )
            logger.info(f"Downloaded and saved PCK Platform CRL to {leaf_crl_path}")
    else:
        # Fetch certs using quote info
        logger.info("No certificate path provided, fetching certificates...")
        root_cert, root_crl, leaf_crl = fetch_crls(
            CertFormat.PEM, certificates_path, "platform"
        )

    # Log successful certificate loading
    if root_cert is not None and root_crl is not None and leaf_crl is not None:
        tdx_logging.log_verification_step(
            "Certificate Loading",
            "PASS",
            "Successfully loaded root cert, root CRL, and leaf CRL",
        )
    else:
        raise ValueError("Failed to load all required certificates and CRLs")

    # Extract SGX extension values
    tdx_logging.log_section_header("SGX Certificate Extensions")
    sgx_exts = quote.signature_data.qe_cert_data.pck_cert_chain.get_sgx_extensions()

    # Convert FMSPC bytes to hex string for validation
    fmspc_hex = sgx_exts["FMSPC"].hex()
    logger.debug(f"FMSPC: {fmspc_hex}")
    fmspc = validate_fmspc(fmspc_hex)

    # Fetch QE Identity
    tdx_logging.log_section_header("QE Identity Fetch")
    qe_identity_raw, qe_identity_certs = fetch_qe_identity(certificates_path, update)

    # Fetch TCB Info
    tdx_logging.log_section_header("TDX TCB Info Fetch")
    tcb_info_raw, tcb_info_certs = fetch_tcb_info(fmspc, certificates_path, update)

    # Get parsed TCB components from the certificate
    if "TCB_parsed" not in sgx_exts:
        raise ValueError("TCB components not found in PCK certificate extensions")

    logger.info("Successfully loaded all required certificates and collateral")

    return {
        "root_cert": root_cert,
        "root_crl": root_crl,
        "leaf_crl": leaf_crl,
        "qe_identity_raw": qe_identity_raw,
        "qe_identity_certs": qe_identity_certs,
        "tcb_info_raw": tcb_info_raw,
        "tcb_info_certs": tcb_info_certs,
        "sgx_extensions": sgx_exts,
        "fmspc": fmspc,
        "update": update,
    }


def perform_verification_checks(
    quote: Quote, collateral: Dict[str, Any]
) -> Tuple[str, Dict[str, Any], TcbStatus]:
    """
    Perform all TDX quote verification checks using loaded certificates and collateral.

    Args:
        quote: Quote object to verify
        collateral: Dictionary of certificates and collateral from load_certificates_and_collateral()

    Returns:
        Tuple of (report data hex string, TCB dictionary, combined TCB status)

    Raises:
        ValueError: For verification failures
    """
    # Extract from collateral dict and validate all required items are present
    required_collateral = [
        "root_cert",
        "root_crl",
        "leaf_crl",
        "qe_identity_raw",
        "qe_identity_certs",
        "tcb_info_raw",
        "tcb_info_certs",
        "update",
    ]

    missing_items = []
    for item in required_collateral:
        if item not in collateral or collateral[item] is None:
            missing_items.append(item)

    if missing_items:
        raise ValueError(
            f"Missing required collateral items: {', '.join(missing_items)}"
        )

    root_cert = collateral["root_cert"]
    root_crl = collateral["root_crl"]
    leaf_crl = collateral["leaf_crl"]
    qe_identity_raw = collateral["qe_identity_raw"]
    qe_identity_certs = collateral["qe_identity_certs"]
    tcb_info_raw = collateral["tcb_info_raw"]
    tcb_info_certs = collateral["tcb_info_certs"]
    try:
        sgx_exts = collateral["sgx_extensions"]
    except KeyError:
        sgx_exts = quote.signature_data.qe_cert_data.pck_cert_chain.get_sgx_extensions()

    pck_cert_chain = quote.signature_data.qe_cert_data.pck_cert_chain

    # Check certificate dates
    for cert in pck_cert_chain.certificates:
        if not validate_certificate_dates(cert):
            raise ValueError(
                f"Certificate '{cert.subject.rfc4514_string()}' is expired or not yet valid"
            )
        tdx_logging.log_verification_step(
            "Certificate Date Validation",
            "PASS",
            f"Certificate '{cert.subject.rfc4514_string()}' is within valid date range",
        )

    # Verify the chain from the quote
    if not pck_cert_chain.verify_chain():
        raise ValueError("PCK certificate chain verification failed")
    tdx_logging.log_verification_step(
        "PCK Certificate Chain Verification", "PASS", "PCK certificate chain is valid"
    )

    # Check Intel root cert matches root cert from chain
    if pck_cert_chain.cert_chain:
        if pck_cert_chain.cert_chain[-1].fingerprint(
            hashes.SHA256()
        ) != root_cert.fingerprint(hashes.SHA256()):
            raise ValueError(
                "Root certificate in PCK chain does not match provided Root CA certificate"
            )
        tdx_logging.log_verification_step(
            "Fingerprint Root Certificate Match",
            "PASS",
            "Root certificate in PCK chain matches provided Root CA certificate",
        )
    else:
        # TODO implement for other quote types
        raise ValueError(
            "PCK certificate chain is incomplete, cannot verify root certificate"
        )

    if not verify_crl(root_crl, root_cert.public_key()):
        raise ValueError("Root CA CRL verification failed")
    tdx_logging.log_verification_step(
        "Root CA CRL Verification", "PASS", "Root CA CRL is valid"
    )

    if not verify_crl(leaf_crl, pck_cert_chain.cert_chain[0].public_key()):
        raise ValueError("PCK CRL verification failed")
    tdx_logging.log_verification_step(
        "PCK CRL Verification", "PASS", "PCK CRL is valid"
    )

    # Check platform cert against root CRL
    if not check_certificate_against_crl(pck_cert_chain.cert_chain[0], root_crl):
        raise ValueError("PCK certificate is revoked according to Root CA CRL")
    tdx_logging.log_verification_step(
        "Platform Certificate Revocation Check (Root CRL)",
        "PASS",
        "Platform certificate is not revoked according to Root CA CRL",
    )
    # Check pck cert against leaf CRL
    if not check_certificate_against_crl(pck_cert_chain.pck_cert, leaf_crl):
        raise ValueError("PCK certificate is revoked according to Platform CRL")
    tdx_logging.log_verification_step(
        "PCK Certificate Revocation Check (Platform CRL)",
        "PASS",
        "PCK certificate is not revoked according to Platform CRL",
    )

    tdx_logging.log_verification_step(
        "CRL Check", "PASS", "All certificates are valid (not revoked)"
    )

    # Verify cryptographic signatures
    tdx_logging.log_section_header("Cryptographic Signature Verification")

    # Verify the QE report signature
    verify_qe_report_signature(quote)

    # Verify the quote signature
    verify_quote_signature(quote)

    # Verify attestation key binding to QE report
    tdx_logging.log_section_header("Attestation Key Binding")
    verify_attestation_key_binding(quote)

    tdx_logging.log_section_header("Verification Complete")
    logger.info("âœ“ All cryptographic verification checks passed successfully!")

    # Verify QE Identity
    tdx_logging.log_section_header("QE Identity Verification")
    try:
        qe_tcb = verify_enclave_identity(
            quote.signature_data.qe_cert_data.qe_report,
            qe_identity_raw,
            qe_identity_certs,
            root_cert,
            root_crl,
        )
    except Exception as e:
        raise ValueError(f"Enclave identity verification failed: {str(e)}")

    tdx_logging.log_verification_step(
        "Enclave Identity Verification", "PASS", "Enclave identity is valid"
    )
    logger.info(f"QE TCB Status: {qe_tcb.status.value}")
    if qe_tcb.advisory_ids:
        logger.info(f"QE Advisory IDs: {', '.join(qe_tcb.advisory_ids)}")

    # Verify TCB Info
    tdx_logging.log_section_header("TDX TCB Info Validation")
    tcb_components = sgx_exts["TCB_parsed"]

    try:
        tcb_dict = verify_tcb_info(
            quote,
            tcb_components,
            tcb_info_raw,
            tcb_info_certs,
            root_cert,
            root_crl,
        )
    except Exception as e:
        raise ValueError(f"TCB Info verification failed: {str(e)}")

    tdx_logging.log_verification_step(
        "TCB Info Verification", "PASS", "TCB Info is valid"
    )

    # Verify TD is not in debug mode
    # Do this last so if we are trying to debug we can still see all other verification steps
    tdx_logging.log_section_header("TD Attributes Verification")
    verify_td_attributes(quote)

    # Log TCB statuses
    logger.info("=== TCB Status Summary ===")
    tcb_dict["qe_tcb"] = qe_tcb
    statuses = []
    for tcb_name, tcb in tcb_dict.items():
        if tcb:
            logger.info(f"{tcb_name} Status: {tcb.status}")
            statuses.append(tcb.status)
            if tcb.advisory_ids:
                logger.info(f"{tcb_name} Advisory IDs: {', '.join(tcb.advisory_ids)}")
        else:
            logger.warning(f"{tcb_name} TCB information missing")

    combined_status = combine_tcb_status(*statuses)

    logger.info("Combined TCB status: " + combined_status.value)
    if combined_status.is_terminal():
        logger.error("Combined TCB status is terminal, attestation failed")
        raise ValueError(f"Combined TCB status is terminal: {combined_status.value}")

    tcb_dict["update"] = collateral["update"]
    return quote.body.report_data.hex(), tcb_dict, combined_status


def verify_quote_bytes(
    quote_bytes: bytes,
    certificates_path: str = default_path,
    collateral: Optional[Dict[str, Any]] = None,
    debug: bool = False,
    verbose: bool = False,
    update: str = "standard",
) -> Tuple[Quote, str, Dict[str, Any], Dict[str, Any], TcbStatus]:
    """
    Verify a TDX attestation quote from raw bytes.

    Parses the raw quote bytes and performs complete verification including
    signature validation, certificate chain verification, and TCB status evaluation.

    Args:
        quote_bytes: Raw quote bytes to verify
        certificates_path: Path to certificates directory (if certificates not provided)
        collateral: Dictionary of certificates (if already loaded)
        debug: Enable debug mode for detailed parsing information
        verbose: Print verbose information during verification
        update: Update policy for fetching collateral ("standard" or "early")

    Returns:
        Tuple containing:
        - Quote: Parsed quote object
        - str: Report data as hex string
        - Dict: Collateral dictionary with certificates
        - Dict: TCB dictionary with status information
        - TcbStatus: Combined TCB status

    Raises:
        ValueError: If verification fails
        FileNotFoundError: If certificates cannot be loaded
    """
    quote = Quote.unpack(quote_bytes, debug=debug)
    if verbose:
        quote.print_details()
    report_data, collateral, tcb_dict, combined_status = verify_quote(
        quote,
        certificates_path=certificates_path,
        collateral=collateral,
        update=update,
    )
    return quote, report_data, collateral, tcb_dict, combined_status


def verify_quote(
    quote: Quote,
    certificates_path: str = default_path,
    collateral: Optional[Dict[str, Any]] = None,
    update: str = "standard",
) -> Tuple[str, Dict[str, Any], Dict[str, Any], TcbStatus]:
    """
    Verify a TDX attestation quote.

    Performs complete cryptographic verification of a TDX quote including
    signature validation, certificate chain verification, and TCB evaluation.

    Args:
        quote: Quote object to verify
        certificates_path: Path to certificates directory (if certificates not provided)
        collateral: Dictionary of certificates and collateral (if already loaded)
        update: Update policy for fetching collateral ("standard" or "early")

    Returns:
        Tuple containing:
        - str: Report data as hex string
        - Dict: Collateral dictionary with certificates
        - Dict: TCB dictionary with status information
        - TcbStatus: Combined TCB status

    Raises:
        ValueError: For verification failures
        FileNotFoundError: If certificates cannot be loaded
    """
    # Verify quote structure
    tdx_logging.log_section_header("Quote Structure Verification")
    verify_quote_structure(quote)

    # Load all certificates and collateral
    if collateral is None:
        collateral = load_certificates_and_collateral(quote, certificates_path, update)

    # Perform all verification checks
    report_data, tcb_dict, combined_status = perform_verification_checks(
        quote, collateral
    )

    return report_data, collateral, tcb_dict, combined_status


def main() -> None:
    """
    Parse command-line arguments, load and verify the TDX quote.

    Command-line interface for TDX quote verification with configurable
    options for debug mode, verbosity, and certificate handling.

    Args:
        Command-line arguments:
        -f, --file: Path to the quote file (default: quote.dat)
        -d, --debug: Enable debug for quote parsing (flag, default: False)
        -v, --verbose: Enable verbose mode (flag, default: False)
        -c, --certs: Path to the certs directory (default: ./certs)
        -r, --reportdata: Print report data at the end of successful verification (flag, default: False)
        -e, --early: Use early update policy for fetching collateral (flag, default: False)

    Raises:
        SystemExit: With appropriate exit code based on verification result

    Examples:
        python verify.py
        python verify.py -f quote.dat -c /path/to/certs
        python verify.py -f quote.dat -c /path/to/certs --verbose
    """
    parser = argparse.ArgumentParser(description="Verify TDX attestation quote")
    parser.add_argument(
        "-f",
        "--file",
        default="quote.dat",
        help="Path to the quote file (default: quote.dat)",
    )
    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        default=False,
        help="Enable debug for quote parsing (flag, default: False)",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        default=False,
        help="Enable verbose mode",
    )
    parser.add_argument(
        "-c",
        "--certs",
        default=default_path,
        help="Path to the certs directory (default: ./certs)",
    )
    parser.add_argument(
        "-r",
        "--reportdata",
        action="store_true",
        default=False,
        help="Print report data at the end of successful verification",
    )
    parser.add_argument(
        "-q",
        "--policy",
        default=None,
        help="Path to the policy file (eg. example_policy.json). If not provided, no policy validation will be performed.",
    )
    parser.add_argument(
        "-e",
        "--early",
        action="store_true",
        default=False,
        help="Use early update policy for fetching collateral",
    )
    args = parser.parse_args()

    # If debug mode is on, automatically enable verbose mode
    if args.debug:
        args.verbose = True

    # Setup logging for CLI mode
    logger = tdx_logging.setup_cli_logging(verbose=args.verbose, quiet=False)

    try:
        # Try to open and read the quote file
        with open(args.file, "rb") as file:
            quote_bytes = file.read()

        # Verify the quote
        quote, report_data, _, tcb_dict, _ = verify_quote_bytes(
            quote_bytes=quote_bytes,
            certificates_path=args.certs,
            debug=args.debug,
            verbose=args.verbose,
            update="early" if args.early else "standard",
        )

        if args.policy:
            validate_quote_with_policy(quote, tcb_dict, args.policy)

        if args.reportdata:
            logger.info("\n\n")
            logger.info(report_data)
        return 0  # Success exit code
    except FileNotFoundError as e:
        logger.error(str(e))
        return 1  # Error exit code
    except (ValueError, Exception) as e:
        logger.error(f"Verification error: {e}")
        if args.debug:
            import traceback

            traceback.print_exc()
        return 1  # Error exit code


if __name__ == "__main__":
    main()
